package api

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"github.com/swaggest/openapi-go"
	"io"
	"math/rand"
	"mime/multipart"
	"net/http"
	"strconv"
	"strings"
)

type DrunkBishopRequest struct {
	Width  int    `query:"width" description:"Width of the image" example:"17" default:"17" required:"false"`
	Height int    `query:"height" description:"Height of the image" example:"9" default:"9" required:"false"`
	Seed   string `query:"seed" description:"Random seed used to generate image when body is empty" default:"random" required:"false"`
	Wrap   bool   `query:"wrap" description:"Wrap around the image with ASCII decorations" example:"true" default:"true" required:"false"`
}

func RouteDrunkBishop(path string, builder *RouteBuilder) {
	builder.Mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodOptions {
			w.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS")
			w.WriteHeader(http.StatusOK)
			return
		}
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		data, err := io.ReadAll(r.Body)
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte("Invalid request body"))
			return
		}
		hash := [32]byte{}
		var width = 17
		var height = 9
		var seed int64
		var widthStr = r.URL.Query().Get("width")
		var heightStr = r.URL.Query().Get("height")
		var seedStr = r.URL.Query().Get("seed")
		if widthStr != "" {
			width, err = strconv.Atoi(widthStr)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				_, _ = w.Write([]byte("Invalid width parameter"))
				return
			}
		}
		if heightStr != "" {
			height, err = strconv.Atoi(heightStr)
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				_, _ = w.Write([]byte("Invalid height parameter"))
				return
			}
		}
		if seedStr != "" {
			seed = stringToInt64(seedStr)
		} else {
			seed = rand.Int63()
		}
		if len(data) == 0 {
			var src = rand.NewSource(seed)
			for i := 0; i < len(hash); i++ {
				hash[i] = byte(src.Int63())
			}
		} else {
			hash = sha256.Sum256(data)
		}

		board := drunkBishop(hash, width, height)
		rendered := strings.TrimSuffix(renderDrunkBishop(board), "\n")
		var result string
		if r.URL.Query().Get("wrap") == "true" {
			var footer string
			if len(data) == 0 {
				seedData := make([]byte, 8)
				binary.BigEndian.PutUint64(seedData, uint64(seed))
				footer = base64.StdEncoding.EncodeToString(seedData)
			} else {
				footer = "SHA256"
			}
			result = boxedString("Image", footer, rendered)
		} else {
			result = strings.TrimSpace(rendered)
		}
		w.Header().Set("Content-Type", "text/plain")
		_, _ = w.Write([]byte(result))
	})
}

func ConfigureDrunkBishop(path string, builder *OpenApiBuilder) error {
	context, err := builder.OpenApiReflector.NewOperationContext(http.MethodPost, path)
	if err != nil {
		return err
	}
	context.SetDescription("Generate a Drunk Bishop ASCII image from a byte array.")
	context.SetTags("image")
	context.SetSummary("Drunk Bishop")

	context.AddReqStructure(new(multipart.File), func(cu *openapi.ContentUnit) {
		cu.Description = "File used to generate the Drunk Bishop image"
		cu.ContentType = "application/octet-stream"
	})
	context.AddReqStructure(new(DrunkBishopRequest), func(cu *openapi.ContentUnit) {
		cu.Description = "Drunk Bishop request"
	})

	context.AddRespStructure(new(string), func(cu *openapi.ContentUnit) {
		cu.HTTPStatus = http.StatusOK
		cu.ContentType = "text/plain"
		cu.Description = "Drunk Bishop ASCII image"
		cu.IsDefault = true
	})
	context.AddRespStructure(new(string), func(cu *openapi.ContentUnit) {
		cu.HTTPStatus = http.StatusBadRequest
		cu.ContentType = "text/plain"
		cu.Description = "Invalid request body"
		cu.IsDefault = false
	})

	err = builder.OpenApiReflector.AddOperation(context)
	if err != nil {
		return err
	}
	return nil
}

var drunkBishopSymbols = []rune{
	' ', '.', 'o', '+', '=', '*', 'B', 'O', 'X', '@', '%', '&', '#', '/', '^',
}

func drunkBishop(bytes [32]byte, width, height int) [][]int {
	board := make([][]int, height)
	for i := range board {
		board[i] = make([]int, width)
	}

	x, y := width/2, height/2 // start in the center

	for _, b := range bytes {
		for i := 0; i < 4; i++ { // 4 steps per byte (2 bits per step)
			dir := (b >> (i * 2)) & 0x03
			switch dir {
			case 0: // ↖
				x--
				y--
			case 1: // ↗
				x++
				y--
			case 2: // ↙
				x--
				y++
			case 3: // ↘
				x++
				y++
			}
			if x < 0 {
				x = 0
			}
			if y < 0 {
				y = 0
			}
			if x >= width {
				x = width - 1
			}
			if y >= height {
				y = height - 1
			}
			board[y][x]++
		}
	}
	return board
}

// generated by ChatGPT
func renderDrunkBishop(board [][]int) string {
	height := len(board)
	width := len(board[0])
	sb := strings.Builder{}
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			val := board[y][x]
			if val >= len(drunkBishopSymbols) {
				val = len(drunkBishopSymbols) - 1
			}
			sb.WriteRune(drunkBishopSymbols[val])
		}
		sb.WriteRune('\n')
	}
	return sb.String()
}

// Generated by DeepSeek
func boxedString(header, footer, content string) string {
	// 将内容按行拆分
	lines := strings.Split(content, "\n")

	// 计算最大行宽
	maxWidth := 0
	for _, line := range lines {
		if len(line) > maxWidth {
			maxWidth = len(line)
		}
	}

	// 计算边框宽度
	boxWidth := maxWidth

	// 构建顶栏
	topBarWithHeader := fmt.Sprintf("+-%s[%s]%s-+",
		strings.Repeat("-", (boxWidth-len(header)-4)/2),
		header,
		strings.Repeat("-", (boxWidth-len(header)-3)/2),
	)

	// 构建底栏
	bottomBarWithFooter := fmt.Sprintf("+-%s[%s]%s-+",
		strings.Repeat("-", (boxWidth-len(footer)-4)/2),
		footer,
		strings.Repeat("-", (boxWidth-len(footer)-3)/2),
	)

	// 构建内容框
	var box strings.Builder
	box.WriteString(topBarWithHeader + "\n")

	for _, line := range lines {
		paddedLine := fmt.Sprintf("|%-*s|", boxWidth-4, line) // 每行内容
		box.WriteString(paddedLine + "\n")
	}

	box.WriteString(bottomBarWithFooter + "\n")

	return box.String()
}
